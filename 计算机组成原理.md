# 计算机组成原理

## 一、计算机概要与技术

### 1.1 引言

分类：个人计算机，服务器，嵌入式计算机,个人移动设备（PMD），云计算
$$KB =10^3,KiB=10^{10} ;MB =10^6,MiB=10^{20}$$

### 1.2 计算机系统结构中8个伟大思想

1. 面向摩尔定律的设计
2. 使用抽象简化设计
3. 加速大概率事件
4. 通过并行提高性能
5. 通过流水线提高性能
6. 通过预测提高性能
7. 存储器层次
8. 通过冗余提高可靠性

### 1.3 程序设计入门

层次结构：硬件>系统软件>应用软件
高级语言--编译--：汇编语言--汇编--：机器语言

### 1.4 硬件概念入门

五大部分：

* 输入设备：为计算机提供信息的装置
* 输出设备：将计算结果输出给用户或其它计算机的装置
* 数据通路：在处理器中执行算术操作的部分
* 控制器：处理器中根据程序中的指令指挥数据通路、存储器和I/O设备工作的部分
* 存储器（内存）：程序运行时的存储空间，同时还存储程序运行时所需的数据。

>数据通路和控制器合称“中央处理单元”（CPU）;存储器、数据通路和控制器在信息处理操作中起主要作用，是计算机硬件的主体部分，通常被称为“主机”。

显示器
>CRT显示：阴极管电子轰击，位图显示  
>LCD显示：液晶显示，轻巧低功耗

存储设备：
高速缓存 — 主存储器 — 二级存储器

1. **主存储器**：程序运行时的存储空间，也存放需要处理的数据。也称为内存，由DRAM（动态随机访问存储器）芯片组成。  
2. **高速缓存**：作为DRAM的缓冲，解决CPU和主存之间的速度匹配。由SRAM（静态随机访问存储器）芯片组成，比DRAM 更快，集成度更低。
3. **二级存储器**：非易失性存储器
    * 磁盘
    * 闪存：PMD的二级存储器的标准

### 1.5 性能

#### 性能的定义：

* 响应时间：也叫执行时间，是计算机完成某任务所需要的总时间，包括硬盘访问、内存访问、I/O活动、操作系统开销和CPU执行时间等。PC用户感兴趣
* 吞吐率：也叫带宽（bandwidth），表示单位时间内完成的任务数量，数据中心感兴趣。

#### 性能的度量：

1. 时钟周期：CPU主频的倒数
2. CPU（执行）时间：某一任务在CPU上花费的时间；=用户CPU时间+系统CPU时间

#### CPU性能

一个程序的 CPU执行时间 = 一个程序的CPU时钟周期数/时钟频率

#### 指令性能

一个程序的CPU时钟周期数 = 程序的指令数×每条指令的平均时钟周期数
>CPI：每条指令的平均周期数，表示执行某个程序或程序片断时每条指令所需的时钟周期平均数。

#### 经典CPU性能公式

$$T_{CPU} = 指令数 \times CPI \times 时钟周期时间，（T_{CPU}为CPU时间）$$

## 二、计算机的语言

计算机中信息分为：数据信息（数值与非数值）和控制信息

### 2.1 数据信息表示方法

#### 2.1.1 进制及转换

r进制：$\sum X_i \times r^i$
十进制化为二进制：除2取余，直到被除数为0。余数倒过来
小数：乘2取整，直到小数部分为0

#### 2.1.2 机器数编码

原码：最高位为符号位，其余正常
补码：符号位可参与计算，负数补码为原码除符号位部分取反+1
>符号扩展：补码可将其符号位向前复制多次填满高位
反码：负数除原码符号位取反

#### 2.1.3 数据表示方法

1. 定点表示法
    小数点位置隐含约定，固定不变
2. 浮点表示法
    $$N=(-1)^S \times F \times 2^E$$
    如$(-1)^0\times 0.011011 \times 2^{011}$
    S为符号位；E为N的指数,或称为阶码；F为N的尾数，代表全部有效数值

    1. MIPS中浮点表示如下：
        * 单精度：

            可表示从$2.0\times 10^{-38} - 2.0\times 10^{38}$的数值

        S       |   E   |   F
        :-----: | :----:|:----:
        31(1位) |30-23(8位)|22-0(23位)

        * 双精度：

            可表示从$2.0\times 10^{-308} - 2.0\times 10^{308}$的数值

        S       |   E   |   F
        :-----: | :----:|:----:
        31(1位) |30-20(11位)|19-0

        F |
        :-----:|
        31-0(52位）|

        >科学记数法
        >其中指数均用移码表示，及补码符号位取反 $[E]_移 = E+Bias$;E为指数的真值，Bias 为偏阶，通常 $Bias= 2^n$ ，其中，n为指数的数码位位数， $2^n$ 是符号位的位权。

    2. IEEE 754浮点标准：
        $$N=(-1)^S\times (1+Fraction) \times 2^{Exponent-Bias}$$
        其中单精度的Bias为127$(2^8-1)$,双精度为1023$(2^11-1)$
        Fraction只是尾数域的值，其值在0和1之间，真正有效位的值为： 1+Fraction。（隐含尾数域前有一定点）
        Exponent是指数域的值，Exponent-Bias指明该数的小数点位置，表示数据的大小范围。
        MIPS中的表示与之前相同，只是E换成了Exponent，为无符号数，值为指数+Bias；F换成了Fraction，为小数部分-1

#### 2.1.4 字符表示方法

1. ASCII码：“美国标准信息交换代码”(American Standard Code for Information Interchange)，简称ASCII码。使用8位的字节来表示字符。
2. Unicode编码：是大多数人类语言中字母的通用编码。通常采用16位来表示一个字符。

### 2.2 MIPS指令集

#### 2.2.1 基本概念

指令集：一个给定的计算机体系结构所包含的指令集合。

存储程序：多种类型的指令和数据均以数字形式存储于存储器中。

#### 2.2.2 MIPS的操作数

1. 规定：
    算术指令操作数必须来自寄存器
    * 寄存器大小：32位（1个字）
    * 寄存器个数：32个
    寄存器表示：

    名称     |寄存器号    |用途   |调用时是否保存
    :----:   | :----:    |:----: |:-----:
    $zero    | 0         |常数0  | 不适用
    \$v0~$v1 | 2~3       |计算结果|否
    \$a0~$a3 | 4~7       | 参数  | 否
    \$t0~$t7 | 8~15      | 临时变量|否
    \$s0~$s7 | 16~23     |保存的寄存器| 是
    \$t8~$t9 | 24~25     | 更多临时变量| 否
    $gp      | 28        | 全局指针 |是
    $sp      | 29        | 栈指针  | 是
    $fp      | 30        | 帧指针  | 是
    $ra      | 31        | 返回地址| 是

2. 存储器操作数

    用于存放复杂的数据类型
    编址方法：1个字4个字节，1个字节8位
    lw：取字（load word）

        lw $s1,20(\$s2):\$s1=Memory[\$s2 + 20]

    sw：存字（store word）

        sw  $s1,20(\$s2): Memory[\$s2 + 20]=\$s1

#### 2.2.3 MIPS指令表示

##### MIPS指令类型：

类型    | 6bits  | 5bits  | 5bits  | 5bits  | 5bits | 6bits
:----: | :----: | :----: | :----: | :----: | :----: | :----:
R型 | op | rs | rt  | rd | shamt | funct  
I型 | op | rs | rt  | constant or address  
J型 | op | target address

R型：寄存器类型；I型：立即数类型；J型：跳转指令类型

* op：基本操作操作码  
* rs：第一个源操作数寄存器  
* rt：第二个源操作数寄存器  
* rd：存放操作结果的目的寄存器
* shamt：位移量
* funct：功能

#### 2.2.4 逻辑操作

##### 1. 移位（shift）

对应rd,rt,shamt

1. sll：左移i位，相当于乘2^i，补充0  

        sll $t2,$s0,4
2. srl：右移i位，相当于除以2^i，补充0  

        srl $t2,$s0,4  

##### 2. 按位与，或，取反（AND，OR，NOT）

    and $t0, $t1, $t2
    or $t0, $t1, $t2
    not $t0, $t1, $t2       #t1或t2再取反

##### 3. 立即数与，或（andi，ori）

    andi $s1,$s2,10
    ori $s1,$s2,10

#### 2.2.5 决策指令

* 分支指令：类似于goto指令，跳转到L1标签处

        beq  register1, register2, L1     #相等则分支
        bne  register1, register2, L1     #不相等则分支

* 置位指令：

        slt   $t0, $s3, $s4        # 小于则置位$t0=1 if $s3 < $s4
        slti   $t0, $s2, 10        # 立即数版 $t0=1 if $s2 < 10
        sltu   $t0, $s3, $s4       # 无符号整数版 $t0=1 if $s3 < $s4
* 跳转指令：

        jr  $ra     #return R型
        j   L       #跳转到语句

#### 2.2.6 计算机硬件对过程的支持

* 过程：根据提供的参数执行一定任务的存储的子程序。

    >通过参数传递数值并返回结果。有助于提高程序的可理解性和代码的可重用性。
* MIPS过程调用时寄存器约定：
    >\$a0~$a3：用于传递参数的参数寄存器
    >\$v0~$v1：用于返回值的值寄存器
    >\$ra：用于返回起始点的返回地址寄存器
* 过程调用指令：
    程序计数器（PC）：保存当前运行的指令的地址
    调用者：跳转和链接指令[J型]

        jal   ProcedureAddress
    被调用者：寄存器跳转[R型]

        jr   $ra
* 栈：
    压栈push，出栈pop
    栈指针：$sp

    \$t0~\$t9：不必保存  
    \$s0~\$s7：必须被保存

>如实现C过程:
>```C
>int leaf (int g,int h,int i,int j)
>{
>   int f;
>   f = (g + h) - (i + j);
>   return f;
>}
>```
>参数变量g，h，i和j对应参数寄存器\$a0-a3,f则对应\$s0.MIPS代码如下
>
>       addi $sp, $sp, -12  #留出3个栈指针的位置
>       sw $t1, 8($sp)      #自上而下保留$t1，$t0，$s0的值
>       sw $t0, 4($sp)
>       sw $s0, 0($sp)
>
>       add $t0, $a0, $a1      # register $t0 contains g + h
>       add $t1, $a2, $a3      # register $t1 contains i + j
>       sub $s0, $t0, $t1       #f = $t0- $t1, which is (g + h)– (i + j)
>       add $v0, $s0, $zero  # returns  f ( $v0 = $s0 + 0)
>
>       lw $s0, 0($sp)     # restore register $s0 for caller
>       lw $t0, 4($sp)     # restore register $t0 for caller
>       lw $t1, 8($sp)     # restore register $t1 for caller
>       addi $sp, $sp, 12    # adjust stack to delete 3 items
>       jr  $ra          # jump back to calling routine

* 嵌套过程:

如

```c
int fact(int n)
{
    if(n < 1) return 1;
    else return(n* fact(n-1));
}
```

则MIPS代码为:

    fact: addi    $sp, $sp, -8                      # adjust stack for 2 items
        sw     $ra, 4($sp)            # save the return address
        sw     $a0, 0($sp)        # save the argument  n
        slti   $t0, $a0, 1             # test for  n  <  1
        beq   $t0, $zero, L1        # if  n  >=  1, go to L1(else)
        addi    $v0, $zero, 1     # return if n <1
        addi    $sp, $sp, 8     # Recover $sp (Why not recover $ra and $a0 ?)
        jr       $ra                     # return to after jal

    L1:  addi   $a0, $a0, -1       # n  >=  1: argument gets ( n  -  1 )
        jal    fact                # call fact with ( n  -  1 )
        lw    $a0, 0($sp)            # return from jal: restore argument n
        lw    $ra, 4($sp)            # restore the return address
        addi   $sp, $sp, 8           # adjust stack pointer to pop 2 items
        mul   $v0, $a0, $v0            # return  n*fact ( n  -  1 )
        jr   $ra                       # return to the  caller

#### 2.2.7 32位立即数和寻址

1. 32位立即数:
    读取立即数指令:
    * lui(load upper immediate)将立即数设置为寄存器的高16为位，其低16位自动补0

            lui  $t0,255
    * ori插入低16位立即数

            ori $s0, $s0, 2304

2. 分支和跳转中寻址

    * 跳转指令：j型

            j 10000 #go to location 10000
        直接寻址：26位地址左移两位后拼接PC中高4位

    * 分支指令： beq，bne I型

            bne &s0, $s1, Exit
        PC相对寻址：PC = (PC + 4) +Branch address(16位地址左移2位形成的18位分支地址)

3. 寻址模式总结：

    1. 立即数寻址：操作数位指令中常数
    2. 寄存器寻址：操作数是寄存器
    3. 基址寻址：操作数在内存中，地址是指令中基址寄存器和常数的和
    4. PC相对寻址：地址是PC和指令中常数的和
    5. 伪直接寻址：地址有指令中26位字段和PC高位连接而成

#### 2.2.8 翻译并执行程序

##### 翻译层次：

    C语言程序 ——（编译器）——汇编语言程序——（汇编器）——目标模块：机器语言模块（+目标库：例程序（机器语言））——（链接器）——可执行代码：机器语言程序——（加载器）——存储器

##### 编译器

C程序->汇编语言程序

##### 汇编器

汇编语言程序->目标文件（机器语言指令）
伪指令：汇编语言指令的一个变种，通常被看作一条汇编指令。

        如move $t0, $t1 #伪指令 -> add $t0,$zero,$t1 #机器语言指令

目标文件包括机器语言指令、数据和指令正确放入内存所需要的信息。

* UNIX目标文件：

    1. 目标文件头，描述目标文件中相关部分的大小和位置。
    2. 代码段
    3. 静态数据段
    4. 重定位信息
    5. 符号表
    6. 调试信息

##### 链接器

将独立的汇编程序拼接起来
目标模块（包括目标库）-> 可执行文件（机器语言程序）

链接工作分为3部分：

* 将代码和数据模块象征性地放入内存
* 决定数据和指令标签的地址
* 修补内部和外部引用

##### 加载器

把目标程序装载到内存中以准备运行。

工作步骤：

* 读取可执行文件头来确定代码段和数据段的大小
* 为正文和数据创建一个足够大的地址空间
* 将可执行文件中的指令和数据复制到内存中
* 把主程序的参数（如果存在）复制到栈顶
* 初始化机器寄存器，将栈指针指向第一个空位置
* 跳转到启动例程，它将参数复制到参数寄存器并且调用程序的main函数。当main函数返回时，启动例程通过系统调用exit终止程序。
