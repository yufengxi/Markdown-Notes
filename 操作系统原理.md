# 操作系统原理

## 一、操作系统引论

1. 操作系统作用

    1. 最重要的系统软件

        * 组成：
            * 软件： 应用软件，系统软件
            * 硬件： I/O设备，存储器，处理器

    2. 系统资源管理者

        * 控制和管理计算机系统硬件和软件资源
            * 软件资源：信息（数据，程序）
            * 硬件资源： I/O设备，存储器，处理器
    3. 裸机第一层系统软件

    4. 用户与裸机间的接口
        * 作业级接口：提供一组系统命令（命令行，菜单式，命令式脚本。图形界面GUI）供用户组织操作
        * 程序级接口： 提供一组系统调用，供永和程序和其他程序调用（如MSDOS的int 21h，WINDOWS的API函数）
    5. 操作系统定义：
        一组控制和管理计算机系统软硬件资源，合理组织计算机工作流程级方便永和的程序集合

2. 操作系统目标
    * 有效性（系统管理人员）
    * 方便性（用户观点）
    * 可扩充性（系统设计员）
    * 开放性

3. 操作系统发展历史

    1. 操作系统发展动力
        1. 提高资源利用率和系统性能
        2. 方便用户
        3. 器件的发展
        4. 计算机体系结构的发展

    2. 手工操作
        * 1946-50s，晶体管，集中计算
        * 机器语言，卡片或纸带
        * 用户（即程序员）独占CPU全部资源，低效；CPU等待用户，利用率低
    3. 单道批次处理系统
        * 50s末-60s中（晶体管），人员出现分工
        * 联机批处理：
            * 用户提交作业：以纸带或卡片为介质
            * 操作员合成批作业：结果磁带介质
            * 作业构成： 程序及使用的数据以及作业控制卡说明书
            * 批作业处理：对批作业中所有作业做相同处理，读入作业，编译连接，启动执行
        * 脱机批处理：
            * 利用卫星机完成输入输出，主机完成计算  
            * 卫星机：完成面向对象的输入输出，中间结果暂存在磁带磁盘上
            * 作业控制命令由监督程序执行
            * 优点： 同一批各作业自以此更替，改善CPU和I/O的使用效率
            * 缺点：磁盘磁带需人工装卸，作业需人分类
        * 优点： 系统吞吐量大，资源利用率高
        * 缺点： 周转时间长，永和无法实现对作业控制

    4. 执行系统阶段
        * 60年代初，发展了通道技术和终端技术
        * 通道：用于控制I/O设备与内存间数据传输，启动后课与CPO并行

    5. 多道批处理系统
        * 60-70年代
        * 宏观：并行，多任务同时运行但未运行完
        * 微观：串行，个任务交替使用CPU

    6. 分时系统
        * 70年代中期至今
        * 多用户分时
        * 前台后台程序分时
        * 按时间片分配
        * 抢先式和非抢先式

    7. 实时系统

4. 操作系统基本类型
    1. 单用户系统：MS-DOS,WINDOW 95/98
    2. 多用户系统： UNIX
    3. 单任务系统： MS-DOS
    4. 多任务系统： UNIX，WINDOWS

5. f

6. 操作系统特征和功能
    1. 操作系统特征
        * 并发性
        * 共享性
        * 虚拟性
        * 异步性
    2. 现代操作系统特征：
        * 微内核结构
        * 多线程
        * 对称多处理
        * 分布式操作系统
        * 面向对象设计

## 二、进程

### 2.1 前驱图和程序进行

* 程序顺序执行的特征：顺序性，封闭性（资源状态仅能由执行程序改变），可再现性（初始条件相同，则结构唯一）
* 程序并发执行的特征：间隔性，失去封闭性，不可再现性（因此要采取措施维持可再现性）

### 2.2 进程的描述

#### 2.2.1 进程性质

* 进程的特征
    1. 动态性
    2. 并发性
    3. 独立性
    4. 异步性
    5. 结构特征（程序段，数据段，进程控制块（PCB））
* 进程的三种基本状态
    1. 运行：进程在CPU上执行
    2. 就绪：进程在内存中等待分配
    3. 阻塞：正在运行的进程收到阻塞不能执行，放弃处理器
    就绪和运行可互相转换，而运行到阻塞，阻塞到就绪是单向的过程
* 创建和终止状态：
    创建PCB -> 就绪 -> 运行 -> 终止

* 挂起操作：
    1. 引入原因：终端用户，负荷调节，操作系统的需要，父进程请求
    <img src = "./pictures/OS/OS1.png"/>

#### 2.2.2 进程数据结构

* OS中管理控制的数据结构：**内存表，设备表，文件表，进程表**。PCB是进程存在的唯一标识

* 进程控制块（PCB块）中的信息：
    1. 进程标识符：
        * 外部标识符：创建时用户指定
        * 内部标识符：OS唯一指定
    2. 处理机状态：
        * 通用寄存器，指令寄存器，程序状态字，用户栈指针
    3. 进程调度：
        * 进程状态，优先级，阻塞原因
    4. 进程控制：
        * 程序和数据地址，资源清单等
* PCB组织方式：1. 线性表 2. 链接方式 3. 索引方式

### 2.3 进程控制

管理状态/用户状态

* 内核：OS中核心功能的集合
    1. 资源管理功能：进程管理，存储器管理，设备管理
    2. 支持功能： 中断处理（最基本功能），时钟管理，**原语操作**（不能中断，不可分割）

* 中断：程序执行过程中，终止CPU上现行程序运行（中断发生后，能够改变处理器内操作执行的顺序）

* 引起进程创建的事件：
    1. 操作系统初始化
    2. 用户登录（分时系统）
    3. 作业调度（外存-内存）
    4. 提供服务（输入/输出）
    5. 应用请求（进程自身）

* 进程的终止：
    从标识符叫所处PCB独处状态
* 进程的阻塞与唤醒：
    1. 向系统请求资源失败
    2. 等待某种操作完成
    3. 新数据尚未到来
    4. 等待新任务到达

### 2.4 线程

* 定义：操作系统进程中呢个狗独立执行的实体，进程的组成部分，是处理器调度的基本单位。进程中允许多个并发线程执行，但每一线程不独立占有进程资源。

* 线程与进程比较

    <img src = "./pictures/OS/OS2.png"/>

    <img src = "./pictures/OS/OS3.png"/>

### 2.5 进程同步

#### 2.5.1 基本概念

* 临界资源： 互斥资源，一段时间内只允许一个进程使用。

* 临界区：每个进程中访问临界资源的代码段。

* 同步机制遵循规律：空闲让进，忙则等待，有限等待，让权等待

#### 2.5.2 信号量机制

1. 整形信号量
    仅两个原子操作wait(S)与signal(S)称为P，V操作原语
2. 记录型信号量

        ```cpp
        Typedf struct {
            int value;  #信号量的值
            struct PCB *list;   # PCB指针
        } semaphore;
        ```

        P(S):申请资源（S==0：刚好能分配,<0:不能分配,>0:可以分配剩余资源），操作后S--
        V(S):释放资源（==0：释放前又1个等待进程,<0:至少有两个等待进程,>0:无等待进程），操作后S++

    * 生产者——消费者问题：

        * 生产者：缓冲区未满将产品放入；
        * 消费者：缓冲区未空取出产品。
        * 整形变量：in = 0, out = 0;
        * 资源信号量： empty = n, full = 0
        * 互斥信号量： mutex = 1

        ```cpp
        Producer:
            P(empty);
            P(mutex);
            buffer(in) = nextp;
            in = (in+1) % n;
            V(mutex);
            V(full);

        Consumer:
            P(full);
            P(mutex);
            netc = buffer(out);
            out = (out+1) % n;
            V(mutex);
            V(empty);
        ```

    * 哲学家进餐问题：

    * 读者，写者问题：

3. AND信号量
    申请资源需要同时用多个临界资源，AND信号量$SP（S_1,S_2...S_n)$。若满足临界资源量>1，则将其一次性分配给进程；若一个资源不满足，则进程等待其他资源也不分配。
    > 哲学家就餐问题
    > ```cpp
    > semaphore fork[5] = {1, 1, 1, 1, 1};
    > SP(fork[(i+1)% 5], fork[i]);
    > SV(fork[(i+1)% 5], fork[i]);

    `SP(S,t,d)`(S:临界资源数；t：下限值；d：资源数量)

### 2.5.3 管程(monitor)

* 定义：定义了能够为并发程序执行的数据结构，这组操作能够同步进程并改变管程中数据

* 组成部分：
    1. 名称：

        ```cpp
        Monitor monitor_name {//管程名
        ```

    2. 共享数据说明

        ```cpp
        share variable declarations;    //共享变量说明
        cond declarations;      //条件变量说明

    3. 对数据结构操作的一组过程

        ```cpp
        Public:     //对数据操作的过程
            void P1(...) {<1>}
            ...
        ```

    4. 共享数据赋值初值

* 条件变量说明：

    * PP(X)：等待某个资源，阻塞并打开管程，等待被唤醒`PP(X)/X.wait`
    * VV(X):唤醒阻塞进程`VV(X)/X.Signal`

## 2.6 进程通信

1. 有界缓冲（低级通信）

2. 管道（pipe）：用于链接度进程和写进程实现他们通信的共享文件，单项信息传递信息方式，先进先出。
    1. 无名管道（存在于内核而非文件系统，无文件名）：

        ```c++
        Main()   {
            int filedes[2],i,pid;
            char inbuf[256];
        if (pipe(filedes)<0)         /* 创建可擦写的无名管道 */
            { perror("could not create unnamed pipe");exit(1);}
        if ((pid = fork())<0)       /* 创建子进程*/
            { perror("could not create subprocess"); exit(2); }
        if (pid>0)        			 /* 父进程*/
            { write(filedes[1],string,23); /* 向管道中写入数据 */
            printf("the parent process sended\n");
            wait(0);  }                 /*等待子进程结束*/
        if (pid==0)        	         /* 子进程*/
            { memset(inbuf, 0, sizeof(inbuf));
            read(filedes[0],inbuf,23);   /* 从管道接收数据 */
            printf("the subparent process received\n");
            printf("%s\n",inbuf); }
        exit(0);}
        ```

    2. 有名管道

3. 消息传递通信的方式

    1. 直接消息传递

    2. 间接通信方式（信箱）

## 三、处理器调度和死锁

### 3.1 处理器调度层次和算法

1. 高级调度（作业调度/长调度/接纳调度）
    决定外存上哪几个作业调入内存，并创建进程，分配资源，放入就绪队列
2. 低级调度（进程调度，短程调度）
    从就绪队列中选择哪个获得处理机，并将处理机分配给进程
3. 中级调度（内存调度，中级调度）
    为了提高内存率采取的外存补充内存的措施。

4. 调度算法目标：
    1. 资源利用率
    2. 公平性
    3. 平衡性
    4. 策略强制执行

5. 分时系统目标：
    1. 响应时间
    2. 均衡性

6. 批处理目标：
    1. 周转时间短
    2. 系统吞吐量高
    3. 处理机利用率高

### 3.2 作业和作业调度

1. 作业：一组统一管理和操作的进程结婚，用户要求计算机系统完成的一项相对独立的工作

2. 作业控制块：作业调度的唯一标识

3. 作业调度：
    * 系统的多道度：系统能够接纳作业的个数，由系统资源决定
    * 先来先服务(FCFS)算法
        * 计算平均周转时间和带权周转时间
    * 短作业（SJF）算法：到达的作业中选择运行时间最短的调用（平均周转时间最短）
    * 高相应比优先调度算法（HRRF）
        $$相应比R_P = 1+ \frac{等待时间}{服务时间}$$
        每个时间段都运行相应比最高的作业
    * 平均周转时间 $FCFS >HRRF > SJF$
    * 优先级调度算法(PSA)

4. 进程调度方式

    * 抢占和非抢占
    * 算法：
        1. 作业算法都可以通用
        2. 轮转(RR)
            时间片轮转算法是轮转中一种，如每个进程执行一定时间，之后进行下一个
        3. 多队列
        4. 