# 数据结构

## 一、绪论

* 数据元素：数据的基本单位，在计算机程序中常作为一个整体进行考虑和处理
* 数据结构：由某一数据对象及该对象中所有数据成员之间的关系组成，是数据的组织形式
    1. 集合结构
    2. 线性结构：线性表,堆栈,队列,串
    3. 树状结构：二叉树，树
    4. 图状结构

* 算法：

    1. 正确性
    2. 具体性
    3. 确定性
    4. 有限性
    5. 可读性
    6. 健壮性

* 算法评价标准

    1. 时间复杂度
        1. O(1)：常数时间复杂度，效率最高
        2. O(n),O(n^2)：多项式阶时间复杂度
        3. O(2^n)：指数时间复杂度，时间最长，算法不实用
        4. O(nlogn)和O(logn)：对数时间复杂度，除常数外效率最高
    2. 空间复杂度：根据存储空间判断

## 二、线性表

### 2.1 线性表逻辑结构

* 定义:
    n个数据元素的有限序列，记作（a1, a2, …, an）
    $$LinearList=(D, R);$$
    D为数据集合，R为前序和后继的联系
* 基本特征：
    简单的线性结构，数据结构的有限集
* 特点：
    第一个和最后一个元素唯一，除首位元素都有唯一的前驱后继  
* 基本操作：

    1. 初始化操作：
        InitList(&L)
    2. 结构销毁操作：
        DestroyList(&L)
    3. 引用型操作:
        Empty(L)    //判空
        Length(L)   //元素数目
        Prior(L, x, &pre)   //返回前驱
        Next( L, x, &next ) //返回后继
        Get( L, i ) //返回第i个元素的值
        Locate( L, x ) //返回第一个与x相等值的位序
    4. 加工型操作：
        Clear( &L ) //清空表
        PutElem( &L, i, x ) //改变数据元素的值
        Insert( &L, i, x )  //插入数据元素
        Delete(&L, i, &x)  //删除数据元素

### 2.2 顺序表

* 定义：将线性表中元素相继放到连续的存储空间中，类似一维数组

* 模板：

```cpp
template <class Type>
class SeqList {
protected:
    Type *data;       //顺序表存储数组
    int MaxSize; //最大允许长度
    int last;      //当前最后元素下标
public:
    SeqList ( int MaxSize = defaultSize );
    ~SeqList ( ) { delete [] data; }
    int Length ( ) const { return last+1; }
    int Locate ( Type x ) const;       //定位
    int Insert ( int i, Type x );      //插入
    int Delete ( int i );              //删除
    int Next ( Type x, Type &next ) ;  //后继
    int Prior ( Type x, Type &pre ) ;  //前驱
    int Empty ( ) { return last ==-1; }
    int Full ( ) { return last == MaxSize-1; }
    Type Get ( int i ) {               //提取
         return i < 0 || i > last？NULL : data[i];
    }
 }
```

部分操作：

* 创建链表：

```cpp
template <class Type>          //构造函数
SeqList<Type> :: SeqList ( int sz ){
if ( sz > 0 ) {
MaxSize = sz;  last = -1;
data = new Type[MaxSize];
if ( data == NULL ) {
    MaxSize = 0;   last = -1;
    return;
        }
    }
}

```

* 插入：时间复杂度O(n)

```cpp
template <class Type>
int SeqList<Type> :: Insert (int i, Type x ) {
//在表中第 i 个位置插入新元素 x
if ( i < 0 || i > last+1 || last == MaxSize-1 )
    return 0;                //插入不成功
else {
    last++;
    for ( int j = last; j > i; j-- )
        data[j] = data[j -1];
    data[i] = x;   return 1;    //插入成功
    }
}
```

* 删除：时间复杂度O(n)

```cpp
template <class Type>
int SeqList<Type> :: Delete ( int i ) {
if ( i <0||i>last ) return 0;
for ( int j = i+1; j <= last; j++ )
    data[j-1] = data[j];
    last—;
    return 1;              //成功删除
}
```

### 2.3 链表

#### 单链表

* 特点：
    1. 每个元素由节点构成  
    2. 存储位置由直接前驱指示
    3. 非随机式的存储结构
    4. 表可扩充
    5. 由节点类和链表类组成

实现如下：

```cpp
class ListNode {       //链表结点类
friend class List;       //链表类为其友元类
private:
    int data;        //结点数据, 整型
    ListNode *link;        //结点指针
 };

//节点也可定义为结构类型

class List {           //链表类定义(嵌套方式)
public:
    //链表操作
private:
    class ListNode {       //嵌套链表结点类
    public:
        int data;
        ListNode *link;
    };
    ListNode *first;  //表头指针
};

```

* 插入：

```cpp
int List::Insert ( const int x, const int i ) {
//在链表第 i 个结点处插入新元素 x
Node *p = first;
int k = 0;
while ( p != NULL && k< i -1 )
    { p = p→link;  k++; }   //找第i-1个结点
if ( p == NULL && first != NULL ) {
    cout << “Invalid position for Insertation!\n”;  return 0;
}
Node *newnode= new Node(x, NULL);
//创建新结点,其数据为x,指针为0
if ( first == NULL || i == 0 ) {  //插在表前
    newnode→link = first;
    if ( first == NULL ) last = newnode;
    first = newnode;
      }
else {                             //插在表中或末尾
    newnode→link = p→link;
if ( p→link == NULL ) last = newnode;
    p→link = newnode;
    }
    return 1;
}
```

* 删除：

```cpp
int List::Remove ( int i ) {
//在链表中删除第i个结点
Node *p = first;  int k = 0;
while ( p != NULL && k< i-1 )
    { p = p→link;  k++; }    //找第i-1个结点
if ( p == NULL ) {
    cout << “Invalid position for Deletion!\n”;
    return 0;
}
```

#### 循环链表

单链表变形，最后一个节点next指针指向头节点，为空的条件为`head -> next == head`

#### 双向链表

指在前驱和后继方向都能游历(遍历)的线性链表，通常采用带表头结点的循环链表形式。

```cpp
p == p→lLink→rLink == p→rLink→lLink
```

插入算法：

```cpp
p→lLink = current;
p→rLink =current→rLink;
current→rLink = p;
current = current→rLink;
current→rLink→lLink = current;
```

删除算法：

```cpp
current→rLink→lLink = current→lLink;
current→lLink→rLink = current→rLink;
```